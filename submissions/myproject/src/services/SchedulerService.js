// SchedulerService.js - Gestion de la planification des tÃ¢ches
import config from '../config/config.js';
import logger from '../utils/logger.js';
import scheduler from '../utils/scheduler.js';
import cronParser from 'cron-parser';

class SchedulerService {
  constructor(trendSnipper) {
    this.trendSnipper = trendSnipper;
  }

  // Planifier une tÃ¢che
  scheduleTask(name, cronExpression, task, runImmediately = false) {
    return scheduler.schedule(name, cronExpression, task, runImmediately);
  }

  // ArrÃªter une tÃ¢che planifiÃ©e
  stopTask(name) {
    return scheduler.stop(name);
  }

  // ArrÃªter toutes les tÃ¢ches
  stopAllTasks() {
    return scheduler.stopAll();
  }

  // Mettre Ã  jour et afficher le prochain temps prÃ©vu pour le post
  updateNextPostTime() {
    try {
      if (config.agent.showNextPostTime) {
        const now = new Date();
        const cronExpression = this.trendSnipper.currentSchedule;
        // Utilisez cronParser.parseExpression au lieu de parseExpression
        const interval = cronParser.parseExpression(cronExpression);
        const nextTime = interval.next().toDate();
        
        this.trendSnipper.cycleStats.nextPostTime = nextTime;
        
        // Formater la date et l'heure
        const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit' };
        
        const formattedDate = nextTime.toLocaleDateString('fr-FR', dateOptions);
        const formattedTime = nextTime.toLocaleTimeString('fr-FR', timeOptions);
        
        logger.info(`ðŸ“… Next post scheduled for: ${formattedDate} at ${formattedTime}`);
      }
    } catch (error) {
      logger.error(`Error calculating next post time: ${error.message}`);
    }
  }

  // Ajuster dynamiquement la planification en fonction de l'activitÃ©
  adjustSchedulingBasedOnActivity() {
    try {
      if (!config.scheduler.dynamic.enabled) return;
      
      logger.info('Evaluating scheduler adjustment based on activity level');
      
      // DÃ©terminer le niveau d'activitÃ© actuel
      let newActivityLevel = 'medium';
      
      // Si nous avons assez de donnÃ©es pour Ã©valuer
      if (this.trendSnipper.cycleStats.cycleTweetCounts.length >= 3) {
        const avgTweets = this.trendSnipper.cycleStats.averageTweetsPerCycle;
        
        if (avgTweets > 300) {
          newActivityLevel = 'high';
        } else if (avgTweets < 50) {
          newActivityLevel = 'low';
        }
        
        // Aussi tenir compte du taux de rÃ©ussite
        const totalCycles = this.trendSnipper.cycleStats.successfulCycles + this.trendSnipper.cycleStats.failedCycles;
        if (totalCycles > 0) {
          const successRate = this.trendSnipper.cycleStats.successfulCycles / totalCycles;
          
          if (successRate < 0.3) {
            // Si le taux de rÃ©ussite est bas, considÃ©rer comme activitÃ© faible
            newActivityLevel = 'low';
          }
        }
      }
      
      // DÃ©finir le nouvel horaire en fonction du niveau d'activitÃ©
      let newSchedule;
      if (newActivityLevel === 'high') {
        newSchedule = config.scheduler.dynamic.minInterval; // plus frÃ©quent
        logger.info('High activity detected, increasing check frequency');
      } else if (newActivityLevel === 'low') {
        newSchedule = config.scheduler.dynamic.maxInterval; // moins frÃ©quent
        logger.info('Low activity detected, decreasing check frequency');
      } else {
        newSchedule = config.scheduler.cronSchedule; // horaire par dÃ©faut
      }
      
      // Mettre Ã  jour la planification si nÃ©cessaire
      if (newSchedule !== this.trendSnipper.currentSchedule) {
        logger.info(`Adjusting schedule from ${this.trendSnipper.currentSchedule} to ${newSchedule}`);
        
        this.trendSnipper.currentSchedule = newSchedule;
        scheduler.stop('trend-detection');
        
        if (this.trendSnipper.autoStart) {
          scheduler.schedule(
            'trend-detection', 
            newSchedule, 
            this.trendSnipper.trendDetectionService.runTrendDetectionCycle.bind(this.trendSnipper.trendDetectionService), 
            false
          );
          logger.info(`Task rescheduled with new frequency: ${newSchedule}`);
        } else {
          logger.info(`New schedule saved (${newSchedule}) but task not automatically rescheduled (auto-start disabled)`);
        }
      } else {
        logger.info(`Maintaining current schedule: ${this.trendSnipper.currentSchedule}`);
      }
      
      // Mettre Ã  jour le niveau d'activitÃ©
      this.trendSnipper.activityLevel = newActivityLevel;
    } catch (error) {
      logger.error(`Error adjusting scheduling: ${error.message}`);
    }
  }
}

export default SchedulerService;